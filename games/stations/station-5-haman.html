<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ”Š ×”×›×• ×‘×”××Ÿ! â€” ××©×™××ª ×¤×•×¨×™×</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Frank+Ruhl+Libre:wght@400;700;900&family=Heebo:wght@300;400;700&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Heebo', sans-serif; background: #0a0015; color: #fff; overflow: hidden; height: 100vh; width: 100vw; }

    /* â•â• Particles â•â• */
    .stars { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; }
    .star { position: absolute; background: #fff; border-radius: 50%; animation: twinkle var(--dur) ease-in-out infinite alternate; }
    @keyframes twinkle { from { opacity: 0.2; transform: scale(0.8); } to { opacity: 1; transform: scale(1.2); } }

    /* â•â• Common Layout â•â• */
    .phase { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; transition: opacity 0.8s, transform 0.8s; }
    .phase.hidden { opacity: 0; pointer-events: none; transform: scale(0.95); }

    .station-badge { font-size: 1rem; color: #ffd700; background: rgba(255,215,0,0.1); border: 1px solid rgba(255,215,0,0.3); padding: 6px 20px; border-radius: 20px; margin-bottom: 15px; letter-spacing: 2px; }
    .title { font-family: 'Frank Ruhl Libre', serif; font-size: clamp(2rem, 6vw, 3.5rem); color: #ffd700; text-shadow: 0 0 30px rgba(255,215,0,0.4); margin-bottom: 10px; }
    .subtitle { font-size: 1.1rem; color: rgba(255,255,255,0.6); margin-bottom: 30px; }
    .btn { font-family: 'Heebo', sans-serif; font-size: 1.2rem; padding: 14px 40px; border: 2px solid #ffd700; background: rgba(255,215,0,0.15); color: #ffd700; border-radius: 12px; cursor: pointer; transition: all 0.3s; letter-spacing: 1px; }
    .btn:hover { background: rgba(255,215,0,0.3); transform: translateY(-2px); box-shadow: 0 5px 20px rgba(255,215,0,0.3); }

    /* â•â• Phase 1: Color Detection â•â• */
    #phase-color { z-index: 20; }
    .camera-container { position: relative; width: 320px; height: 240px; border-radius: 16px; overflow: hidden; border: 3px solid rgba(255,215,0,0.4); box-shadow: 0 0 30px rgba(139,92,246,0.3); }
    .camera-container video { width: 100%; height: 100%; object-fit: cover; }
    .color-indicator { width: 80px; height: 80px; border-radius: 50%; border: 4px solid rgba(255,255,255,0.3); margin: 20px auto; transition: all 0.5s; box-shadow: 0 0 20px rgba(0,0,0,0.3); }
    .color-status { font-size: 1.3rem; color: rgba(255,255,255,0.7); margin-top: 10px; min-height: 2em; }
    .color-matched { animation: colorPulse 0.5s ease-out; }
    @keyframes colorPulse { 0% { transform: scale(1); } 50% { transform: scale(1.3); } 100% { transform: scale(1); } }
    .accept-color-label { font-size: 0.9rem; color: rgba(255,215,0,0.5); margin-top: 8px; }

    /* â•â• Phase 2: Volume Meter Puzzle â•â• */
    #phase-puzzle {
      background: radial-gradient(ellipse at center, #1a0005 0%, #0a0015 100%);
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 0;
    }

    /* Red flash overlay */
    #red-flash {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(255,0,0,0);
      pointer-events: none;
      z-index: 25;
      transition: background 0.05s;
    }

    /* Left: Haman text + instructions */
    .puzzle-left {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex: 1;
      padding: 20px;
      gap: 20px;
    }

    .haman-text {
      font-family: 'Frank Ruhl Libre', serif;
      font-size: clamp(4rem, 12vw, 8rem);
      color: #ff2222;
      text-shadow:
        0 0 20px rgba(255,0,0,0.8),
        0 0 40px rgba(255,0,0,0.5),
        0 0 80px rgba(255,50,50,0.3);
      line-height: 1;
      animation: hamanPulse 1.2s ease-in-out infinite;
      transition: font-size 0.1s, transform 0.1s;
      user-select: none;
    }
    @keyframes hamanPulse {
      0%, 100% { transform: scale(1) rotate(-2deg); filter: brightness(1); }
      50%       { transform: scale(1.08) rotate(2deg); filter: brightness(1.3); }
    }

    .instruction-box {
      background: rgba(255,50,50,0.1);
      border: 2px solid rgba(255,100,100,0.3);
      border-radius: 16px;
      padding: 20px 28px;
      max-width: 380px;
      text-align: center;
    }
    .instruction-text {
      font-size: 1.25rem;
      color: #ffdddd;
      line-height: 1.7;
      font-weight: 700;
    }

    .countdown-display {
      font-family: 'Frank Ruhl Libre', serif;
      font-size: 2.8rem;
      color: #ff6666;
      text-shadow: 0 0 20px rgba(255,50,50,0.7);
      min-height: 3.5rem;
      transition: all 0.2s;
    }
    .countdown-display.active {
      color: #ff2222;
      animation: countdownPulse 0.5s ease-in-out infinite alternate;
    }
    @keyframes countdownPulse {
      from { transform: scale(1); text-shadow: 0 0 20px rgba(255,50,50,0.7); }
      to   { transform: scale(1.1); text-shadow: 0 0 40px rgba(255,0,0,1); }
    }

    /* Right: Volume Meter */
    .puzzle-right {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 20px 30px 20px 20px;
    }

    .volume-label-top {
      font-size: 0.95rem;
      color: rgba(255,200,200,0.7);
      letter-spacing: 1px;
    }

    .meter-wrapper {
      position: relative;
      display: flex;
      align-items: flex-end;
      gap: 0;
    }

    /* The vertical bar container */
    .meter-track {
      position: relative;
      width: 80px;
      height: 380px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.15);
      border-radius: 40px;
      overflow: hidden;
      box-shadow:
        inset 0 0 20px rgba(0,0,0,0.5),
        0 0 30px rgba(255,50,50,0.2);
    }

    /* The fill bar â€” grows upward from bottom */
    .meter-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 0%;
      border-radius: 40px;
      transition: height 0.06s linear;
      background: linear-gradient(
        to top,
        #00cc44 0%,
        #aadd00 30%,
        #ffbb00 55%,
        #ff6600 75%,
        #ff2222 100%
      );
      box-shadow: 0 0 15px rgba(255,100,0,0.4);
    }

    /* Glow shimmer on the fill */
    .meter-fill::after {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 30%;
      background: linear-gradient(to bottom, rgba(255,255,255,0.25), transparent);
      border-radius: 40px 40px 0 0;
    }

    /* Target line at top (100%) */
    .target-line {
      position: absolute;
      top: 0;
      left: -4px;
      right: -4px;
      height: 4px;
      background: #fff700;
      border-radius: 2px;
      box-shadow: 0 0 10px rgba(255,247,0,0.9), 0 0 20px rgba(255,247,0,0.5);
      z-index: 2;
      animation: targetGlow 1s ease-in-out infinite alternate;
    }
    @keyframes targetGlow {
      from { box-shadow: 0 0 8px rgba(255,247,0,0.7); }
      to   { box-shadow: 0 0 18px rgba(255,247,0,1), 0 0 30px rgba(255,200,0,0.6); }
    }

    /* Target label to the side */
    .target-label {
      position: absolute;
      top: -0.6rem;
      right: calc(100% + 10px);
      font-size: 0.9rem;
      color: #fff700;
      white-space: nowrap;
      font-weight: 700;
      text-shadow: 0 0 8px rgba(255,247,0,0.8);
      pointer-events: none;
    }

    /* Percentage number */
    .volume-percent {
      font-family: 'Frank Ruhl Libre', serif;
      font-size: 3rem;
      color: #fff;
      font-weight: 900;
      text-shadow: 0 0 15px rgba(255,150,0,0.6);
      min-width: 90px;
      text-align: center;
      transition: color 0.1s;
    }
    .volume-percent.high { color: #ff4444; text-shadow: 0 0 20px rgba(255,0,0,0.8); }

    .mic-status {
      font-size: 0.9rem;
      color: rgba(255,200,200,0.5);
      text-align: center;
    }
    .mic-status.active { color: #ff8888; }

    /* â•â• dB Meter â•â• */
    .db-meter {
      position: fixed;
      left: 18px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      z-index: 15;
    }
    .db-label {
      font-size: 0.7rem;
      color: rgba(255,200,200,0.5);
      letter-spacing: 1px;
      writing-mode: vertical-rl;
      text-orientation: mixed;
    }
    .db-track {
      width: 24px;
      height: 260px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      position: relative;
      overflow: hidden;
    }
    .db-fill {
      position: absolute;
      bottom: 0; left: 0;
      width: 100%;
      height: 0%;
      border-radius: 12px;
      background: linear-gradient(to top, #00ff88 0%, #ffcc00 50%, #ff3333 100%);
      transition: height 0.05s linear;
    }
    .db-value {
      font-family: 'Frank Ruhl Libre', serif;
      font-size: 1.1rem;
      color: #ff8888;
      font-weight: 700;
      min-width: 50px;
      text-align: center;
    }

    /* â•â• Screen shake â•â• */
    @keyframes screenShake {
      0%   { transform: translate(0,0) rotate(0deg); }
      15%  { transform: translate(-6px, 4px) rotate(-0.5deg); }
      30%  { transform: translate(5px, -4px) rotate(0.5deg); }
      45%  { transform: translate(-4px, 6px) rotate(-0.3deg); }
      60%  { transform: translate(6px, -3px) rotate(0.4deg); }
      75%  { transform: translate(-3px, 5px) rotate(-0.2deg); }
      90%  { transform: translate(4px, -2px) rotate(0.2deg); }
      100% { transform: translate(0,0) rotate(0deg); }
    }
    body.shaking { animation: screenShake 0.18s ease-in-out; }

    /* â•â• Phase 3: Success â•â• */
    #phase-success { background: radial-gradient(ellipse at center, #1a0a3e 0%, #0a0015 100%); z-index: 30; }
    .success-icon { font-size: 5rem; animation: bounce 1s ease-in-out infinite; }
    @keyframes bounce { 0%,100% { transform: translateY(0); } 50% { transform: translateY(-20px); } }
    .success-title { font-family: 'Frank Ruhl Libre', serif; font-size: 2.5rem; color: #ffd700; margin: 15px 0; }
    .clue-box { background: rgba(255,215,0,0.1); border: 2px solid rgba(255,215,0,0.4); border-radius: 16px; padding: 25px 35px; max-width: 500px; margin: 20px auto; }
    .clue-label { font-size: 0.9rem; color: rgba(255,215,0,0.6); margin-bottom: 10px; }
    .clue-text { font-family: 'Frank Ruhl Libre', serif; font-size: 1.5rem; color: #ffd700; line-height: 1.6; }
    .clue-arrow { font-size: 2rem; margin-top: 15px; animation: arrowPulse 1.5s ease-in-out infinite; }
    @keyframes arrowPulse { 0%,100% { transform: translateY(0); opacity: 0.5; } 50% { transform: translateY(10px); opacity: 1; } }

    /* â•â• Confetti â•â• */
    .confetti { position: fixed; top: -10px; width: 10px; height: 10px; z-index: 31; animation: confettiFall var(--fall-dur) linear forwards; }
    @keyframes confettiFall { to { top: 110vh; transform: rotate(var(--rot)) translateX(var(--drift)); } }

    /* â•â• Reset Button â•â• */
    .reset-btn { position: fixed; bottom: 15px; left: 15px; font-size: 0.75rem; color: rgba(255,255,255,0.15); background: none; border: 1px solid rgba(255,255,255,0.1); padding: 4px 12px; border-radius: 6px; cursor: pointer; z-index: 50; }
    .reset-btn:hover { color: rgba(255,255,255,0.4); border-color: rgba(255,255,255,0.3); }

    /* â•â• Mic permission prompt â•â• */
    #mic-prompt {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(20,0,30,0.97); border: 2px solid rgba(255,100,100,0.4);
      border-radius: 20px; padding: 30px 40px; z-index: 40;
      text-align: center; max-width: 380px; display: none;
    }
    #mic-prompt.show { display: block; }
    #mic-prompt h2 { color: #ff8888; font-size: 1.6rem; margin-bottom: 12px; }
    #mic-prompt p { color: rgba(255,255,255,0.7); font-size: 1rem; margin-bottom: 20px; line-height: 1.6; }
  
    /* â•â• Phase: Group Selection â•â• */
    #phase-group { z-index: 21; background: radial-gradient(ellipse at center, #1a0a3e 0%, #0a0015 100%); }
    .group-title { font-family: 'Frank Ruhl Libre', serif; font-size: 2.5rem; color: #ffd700; margin-bottom: 10px; }
    .group-subtitle { font-size: 1.1rem; color: rgba(255,255,255,0.6); margin-bottom: 30px; }
    .group-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; max-width: 500px; }
    .group-btn {
      font-family: 'Heebo', sans-serif; font-size: 1.8rem; font-weight: 900;
      width: 80px; height: 80px; border-radius: 50%;
      border: 3px solid rgba(255,215,0,0.4); background: rgba(255,215,0,0.1);
      color: #ffd700; cursor: pointer; transition: all 0.3s;
      display: flex; align-items: center; justify-content: center;
    }
    .group-btn:hover { background: rgba(255,215,0,0.3); transform: scale(1.15); box-shadow: 0 0 25px rgba(255,215,0,0.4); }
  </style>
</head>
<body>
  <!-- Stars Background -->
  <div class="stars" id="stars"></div>

  <!-- Red flash overlay -->
  <div id="red-flash"></div>

  <!-- Mic permission prompt -->
  <div id="mic-prompt">
    <h2>ğŸ¤ ××¤×©×¨×• ××™×§×¨×•×¤×•×Ÿ</h2>
    <p>×›×“×™ ×œ×©×—×§, ×™×© ×œ××©×¨ ×’×™×©×” ×œ××™×§×¨×•×¤×•×Ÿ ×‘×—×œ×•×Ÿ ×”×§×•×¤×¥.</p>
    <button class="btn" id="mic-retry-btn">ğŸ¤ × ×¡×” ×©×•×‘</button>
  </div>

  <!-- â•â•â• Phase 1: Color Detection â•â•â• -->
  <div class="phase" id="phase-color">
    <div class="station-badge">ğŸ”Š ×ª×—× ×” 5</div>
    <div class="title">×”×›×• ×‘×”××Ÿ!</div>
    <div class="subtitle">×¦×‘×¢×• ×“×£ ×œ×‘×Ÿ ×‘×¦×‘×¢ ×”××ª××™× ×•×”×¨×™××• ×œ××¦×œ××”</div>
    <div class="camera-container">
      <video id="camera" autoplay playsinline muted></video>
      <canvas id="color-canvas" style="display:none"></canvas>
    </div>
    <div class="color-indicator" id="color-indicator"></div>
    <div class="color-status" id="color-status">×××ª×™×Ÿ ×œ××¦×œ××”...</div>
    <div class="accept-color-label" id="accept-label"></div>
  </div>

  <!-- dB Meter (visible during puzzle phase) -->
  <div class="db-meter" id="db-meter" style="display:none;">
    <div class="db-value" id="db-value">0 dB</div>
    <div class="db-track">
      <div class="db-fill" id="db-fill"></div>
    </div>
    <div class="db-label">LIVE dB</div>
  </div>

  <!-- â•â•â• Phase 2: Volume Meter Puzzle â•â•â• -->
  
  <!-- â•â•â• Phase: Group Selection â•â•â• -->
  <div class="phase hidden" id="phase-group">
    <div class="group-title">ğŸ‘¥ ××™ ××ª×?</div>
    <div class="group-subtitle">×‘×—×¨×• ××ª ××¡×¤×¨ ×”×§×‘×•×¦×” ×©×œ×›×</div>
    <div class="group-grid" id="group-grid"></div>
  </div>

  <div class="phase hidden" id="phase-puzzle">

    <!-- LEFT: Haman + instructions -->
    <div class="puzzle-left">
      <div class="haman-text" id="haman-text">×”Ö¸×Ö¸×Ÿ!</div>
      <div class="instruction-box">
        <div class="instruction-text">×¦×¢×§×• ×›×•×œ× ×‘×™×—×“: <strong>×”××Ÿ!!!</strong><br>×›×œ ×¦×¢×§×” ×××œ××ª ××ª ×”××“ â€” ××œ××• ××•×ª×•!</div>
      </div>
      <div class="countdown-display" id="countdown-display"></div>
      <div class="mic-status" id="mic-status">ğŸ¤ ×××–×™×Ÿ...</div>
    </div>

    <!-- RIGHT: Volume meter bar -->
    <div class="puzzle-right">
      <div class="volume-label-top">ğŸ”¥ ××“ ×”×”××Ÿ â€” ××œ××• ××•×ª×•!</div>

      <div class="meter-wrapper">
        <!-- Target label outside the track -->
        <div style="position:relative; display:flex; align-items:flex-end; gap:14px;">
          <div style="position:relative;">
            <div class="meter-track">
              <div class="meter-fill" id="meter-fill"></div>
              <div class="target-line"></div>
            </div>
            <div class="target-label">ğŸ¯ ××œ××•!</div>
          </div>
          <div class="volume-percent" id="volume-percent">0%</div>
        </div>
      </div>

      <div class="mic-status" style="margin-top:5px; font-size:0.8rem; color:rgba(255,150,150,0.4);">ğŸ“¢ ×“×‘×¨×• ×™×©×™×¨×•×ª ×œ××™×§×¨×•×¤×•×Ÿ</div>
    </div>

  </div>

  <!-- â•â•â• Phase 3: Success â•â•â• -->
  <div class="phase hidden" id="phase-success">
    <div class="success-icon">ğŸ‰</div>
    <div class="success-title">×”××Ÿ ×”×•×‘×¡! × ×™×¦×—×ª×!</div>
    <div class="clue-box">
      <div class="clue-label">ğŸ“ ×”×¨××– ×œ×©×œ×‘ ×”×‘×:</div>
      <div class="clue-text" id="clue-display"></div>
    </div>
    <div class="clue-arrow">â¬‡ï¸</div>
    <button class="btn" onclick="resetStation()" style="margin-top:20px; font-size:1rem; padding:10px 30px;">ğŸ”„ ×§×‘×•×¦×” ×”×‘××”</button>
  </div>

  <button class="reset-btn" onclick="resetStation()">××™×¤×•×¡</button>

  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONFIG
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const CONFIG = {
      stationNumber: 5,
      stationName: '×”×›×• ×‘×”××Ÿ!',
      acceptColor: 'orange',
      targetEnergy: 3000,      // total accumulated energy to win â€” need REAL shouting
      minVolToCount: 15,       // minimum volume % to start accumulating
      clueText: '×´×•×™×›×ª×‘×• ×‘×¡×¤×¨ ×“×‘×¨×™ ×”×™××™××´ â€” ×‘××§×•× ×©×‘×• × ×©××¨×™× ×”×¡×¤×¨×™×, ×œ×™×“ ×¡×™×¤×•×¨×™ ×”× ×‘×™××™×, ×¡×’×•×œ ×›×œ×‘×•×© ××œ×›×•×ª ×™× ×•×—',
    };

    // â•â• Color definitions (identical to station-1) â•â•
    const COLORS = {
      red:    { he: '××“×•× ğŸ”´', min: [150, 0, 0],   max: [255, 100, 100], bg: '#ff3333' },
      blue:   { he: '×ª×›×œ×ª ğŸ”µ', min: [0, 0, 140],   max: [100, 100, 255], bg: '#3366ff' },
      green:  { he: '×™×¨×•×§ ğŸŸ¢', min: [0, 120, 0],   max: [100, 255, 100], bg: '#33cc33' },
      yellow: { he: '×¦×”×•×‘ ğŸŸ¡', min: [180, 180, 0], max: [255, 255, 100], bg: '#ffcc00' },
      orange: { he: '×›×ª×•× ğŸŸ ', min: [200, 100, 0], max: [255, 180, 80],  bg: '#ff8800' },
      purple: { he: '×¡×’×•×œ ğŸŸ£', min: [100, 0, 120], max: [200, 80, 255],  bg: '#9933ff' },
    };

    // â•â• Stars â•â•
    const starsEl = document.getElementById('stars');
    for (let i = 0; i < 80; i++) {
      const s = document.createElement('div');
      s.className = 'star';
      const size = Math.random() * 3 + 1;
      s.style.cssText = `width:${size}px;height:${size}px;top:${Math.random()*100}%;left:${Math.random()*100}%;--dur:${1+Math.random()*3}s;animation-delay:${Math.random()*3}s;`;
      starsEl.appendChild(s);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Phase 1: Color Detection (reused from station-1)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const video   = document.getElementById('camera');
    const colorCanvas = document.getElementById('color-canvas');
    const colorCtx    = colorCanvas.getContext('2d', { willReadFrequently: true });
    const indicator   = document.getElementById('color-indicator');
    const statusEl    = document.getElementById('color-status');
    const acceptLabel = document.getElementById('accept-label');

    acceptLabel.textContent = `×ª×—× ×” ${CONFIG.stationNumber}`;
    let colorDetected = false;
    let matchCount = 0;

    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment', width: 320, height: 240 } });
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          colorCanvas.width = 320;
          colorCanvas.height = 240;
          statusEl.textContent = 'ğŸ¨ ×¦×‘×¢×• ×“×£ ×œ×‘×Ÿ ×‘×¦×‘×¢ ×”× ×›×•×Ÿ ×•×”×¨×™××• ×œ××¦×œ××”';
          detectColor();
        };
      } catch (e) {
        statusEl.textContent = 'âš ï¸ ××™×Ÿ ×’×™×©×” ×œ××¦×œ××” â€” ×œ×—×¦×• ×¢×œ "××¤×©×¨"';
      }
    }

    function detectColor() {
      if (colorDetected) return;
      colorCtx.drawImage(video, 0, 0, 320, 240);
      const cx = 110, cy = 70, cw = 100, ch = 100;
      const imageData = colorCtx.getImageData(cx, cy, cw, ch);
      const data = imageData.data;
      let rSum = 0, gSum = 0, bSum = 0, count = 0;
      for (let i = 0; i < data.length; i += 4) {
        rSum += data[i]; gSum += data[i+1]; bSum += data[i+2]; count++;
      }
      const r = Math.round(rSum / count);
      const g = Math.round(gSum / count);
      const b = Math.round(bSum / count);
      indicator.style.background = `rgb(${r},${g},${b})`;

      let detected = null;
      for (const [name, col] of Object.entries(COLORS)) {
        if (r >= col.min[0] && r <= col.max[0] && g >= col.min[1] && g <= col.max[1] && b >= col.min[2] && b <= col.max[2]) {
          detected = name; break;
        }
      }

      if (detected === CONFIG.acceptColor) {
        matchCount++;
        statusEl.textContent = `ğŸ¯ ××–×”×” ${COLORS[detected].he}... (${matchCount}/10)`;
        statusEl.style.color = '#4ade80';
        if (matchCount >= 10) {
          colorDetected = true;
          indicator.classList.add('color-matched');
          statusEl.textContent = `âœ… ${COLORS[detected].he} â€” ×–×•×”×”! × ×›× ×¡×™×...`;
          setTimeout(showGroupSelect, 1200);
          return;
        }
      } else if (detected) {
        matchCount = Math.max(0, matchCount - 1);
        statusEl.textContent = `âŒ ×–×” ×œ× ×”×¦×‘×¢ ×”× ×›×•×Ÿ â€” × ×¡×• ×ª×—× ×” ××—×¨×ª`;
        statusEl.style.color = '#f87171';
      } else {
        matchCount = Math.max(0, matchCount - 1);
        // Check if something colorful is visible (not just gray/dark)
        const maxC = Math.max(r, g, b);
        const minC = Math.min(r, g, b);
        const saturation = maxC > 30 ? (maxC - minC) / maxC : 0;
        if (saturation > 0.25 && maxC > 60) {
          statusEl.textContent = 'ğŸ” ××–×”×” ×¦×‘×¢... ×§×¨×‘×• ××ª ×”×“×£ ×”×¦×‘×•×¢ ×œ××¦×œ××”';
          statusEl.style.color = '#fbbf24';
        } else {
          statusEl.textContent = 'ğŸ¨ ×¦×‘×¢×• ×“×£ ×œ×‘×Ÿ ×‘×¦×‘×¢ ×”× ×›×•×Ÿ ×•×”×¨×™××• ×œ××¦×œ××”';
          statusEl.style.color = 'rgba(255,255,255,0.7)';
        }
      }
      requestAnimationFrame(detectColor);
    }

    startCamera();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Phase 2: Volume Meter
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let audioCtx = null;
    let analyser = null;
    let micStream = null;
    let volumeData = new Float32Array(0);
    let accumulatedEnergy = 0;       // cumulative energy â€” only goes UP
    let puzzleActive = false;
    let puzzleSolved = false;
    let lastFrameTime = 0;
    let shakeTimeout = null;
    let animFrameId = null;
    let peakVolume = 0;

    const meterFill    = document.getElementById('meter-fill');
    const volumePercEl = document.getElementById('volume-percent');
    const hamanText    = document.getElementById('haman-text');
    const countdownEl  = document.getElementById('countdown-display');
    const micStatusEl  = document.getElementById('mic-status');
    const redFlash     = document.getElementById('red-flash');
    // â•â• Group Selection â•â•
    let selectedGroup = null;
    const groupGrid = document.getElementById('group-grid');
    for (let i = 1; i <= 10; i++) {
      const btn = document.createElement('button');
      btn.className = 'group-btn';
      btn.textContent = i;
      btn.onclick = () => selectGroup(i);
      groupGrid.appendChild(btn);
    }

    function showGroupSelect() {
      if (video.srcObject) video.srcObject.getTracks().forEach(t => t.stop());
      document.getElementById('phase-color').classList.add('hidden');
      document.getElementById('phase-group').classList.remove('hidden');
    }

    function selectGroup(num) {
      selectedGroup = num;
      document.getElementById('phase-group').classList.add('hidden');
      startPuzzle();
    }

    function saveCompletion() {
      if (!selectedGroup) return;
      const key = 'purim_progress';
      const data = JSON.parse(localStorage.getItem(key) || '{}');
      if (!data[selectedGroup]) data[selectedGroup] = [];
      if (!data[selectedGroup].includes(CONFIG.stationNumber)) {
        data[selectedGroup].push(CONFIG.stationNumber);
      }
      localStorage.setItem(key, JSON.stringify(data));
    }



    function startPuzzle() {
      if (video.srcObject) video.srcObject.getTracks().forEach(t => t.stop());
      document.getElementById('phase-color').classList.add('hidden');
      document.getElementById('phase-puzzle').classList.remove('hidden');
      initMicrophone();
    }

    let smoothedVolume = 0;  // exponential moving average

    const dbValueEl = document.getElementById('db-value');
    const dbFillEl  = document.getElementById('db-fill');
    const dbMeterEl = document.getElementById('db-meter');

    async function initMicrophone() {
      // Try multiple approaches â€” browsers handle audio constraints differently
      const configs = [
        { audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } },
        { audio: { echoCancellation: false, noiseSuppression: false } },
        { audio: true },
      ];
      for (const config of configs) {
        try {
          micStream = await navigator.mediaDevices.getUserMedia({ ...config, video: false });
          break;
        } catch (e) { continue; }
      }
      if (!micStream) {
        const prompt = document.getElementById('mic-prompt');
        prompt.classList.add('show');
        document.getElementById('mic-retry-btn').onclick = () => {
          prompt.classList.remove('show');
          initMicrophone();
        };
        return;
      }

      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioCtx.createMediaStreamSource(micStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;         // 1024 samples for time domain
      analyser.smoothingTimeConstant = 0.3; // low smoothing = responsive
      source.connect(analyser);
      volumeData = new Uint8Array(analyser.fftSize);  // time domain buffer

      dbMeterEl.style.display = 'flex'; // show dB meter
      puzzleActive = true;
      micStatusEl.textContent = 'ğŸ¤ ××™×§×¨×•×¤×•×Ÿ ×¤×¢×™×œ â€” ×¦×¢×§×•!';
      micStatusEl.classList.add('active');
      lastFrameTime = performance.now();
      volumeLoop(performance.now());
    }

    function getVolumeRMS() {
      // â•â•â• TIME DOMAIN RMS â€” measures raw amplitude, not filtered frequencies â•â•â•
      // This captures ALL sound regardless of browser processing
      analyser.getByteTimeDomainData(volumeData);
      let sumSquares = 0;
      for (let i = 0; i < volumeData.length; i++) {
        const sample = (volumeData[i] - 128) / 128;  // normalize to -1..1
        sumSquares += sample * sample;
      }
      const rms = Math.sqrt(sumSquares / volumeData.length);
      // rms: 0 = silence, ~0.01 = quiet room, ~0.1 = talking, ~0.5+ = shouting
      return rms;
    }

    function rmsToDb(rms) {
      if (rms < 0.0001) return -80;
      return 20 * Math.log10(rms);
    }

    function volumeLoop(now) {
      if (!puzzleActive || puzzleSolved) return;
      animFrameId = requestAnimationFrame(volumeLoop);

      const dt = now - lastFrameTime;
      lastFrameTime = now;
      if (dt <= 0 || dt > 200) { lastFrameTime = now; return; }

      const rms = getVolumeRMS();
      const db = rmsToDb(rms);

      // Scale RMS to 0-100 for display
      // rms 0.01 = ~0%, rms 0.5 = ~100%
      const vol = Math.min(100, Math.max(0, Math.round((rms / 0.4) * 100)));

      // Smoothing for display
      const attackSpeed = 0.5;
      const decaySpeed = 0.1;
      if (vol > smoothedVolume) {
        smoothedVolume += (vol - smoothedVolume) * attackSpeed;
      } else {
        smoothedVolume += (vol - smoothedVolume) * decaySpeed;
      }
      const displayVol = Math.round(smoothedVolume);

      // Update dB meter (live, separate from cumulative)
      const dbDisplay = Math.round(Math.max(-60, db));
      const dbPercent = Math.min(100, Math.max(0, ((db + 60) / 60) * 100));
      dbValueEl.textContent = `${dbDisplay} dB`;
      dbFillEl.style.height = dbPercent + '%';

      // â•â•â• CUMULATIVE ENERGY â•â•â•
      if (vol >= CONFIG.minVolToCount) {
        accumulatedEnergy += (vol / 100) * (dt / 1000) * 100;
      }
      accumulatedEnergy = Math.min(accumulatedEnergy, CONFIG.targetEnergy);

      updateMeterUI(displayVol, accumulatedEnergy);
    }

    function updateMeterUI(currentVol, energy) {
      // Progress toward goal (0-100%)
      const progress = Math.min(100, (energy / CONFIG.targetEnergy) * 100);

      // Update bar â€” shows ACCUMULATED progress, not current volume
      meterFill.style.height = progress + '%';

      // Show energy counter
      volumePercEl.textContent = `${Math.round(energy)}`;
      volumePercEl.classList.toggle('high', progress >= 80);

      // Haman text: grows with CURRENT volume (live feedback)
      const baseSize = 4;
      const maxExtra = 6;
      const extra = (currentVol / 100) * maxExtra;
      hamanText.style.fontSize = `clamp(${baseSize}rem, ${baseSize + extra}vw, ${baseSize + extra + 2}rem)`;

      // Red flash: proportional to current volume above 40%
      if (currentVol > 40) {
        const alpha = ((currentVol - 40) / 60) * 0.35;
        redFlash.style.background = `rgba(255,0,0,${alpha.toFixed(3)})`;
      } else {
        redFlash.style.background = 'rgba(255,0,0,0)';
      }

      // Screen shake when volume is strong
      if (currentVol >= 50) {
        triggerShake();
      }

      // Track peak
      if (currentVol > peakVolume) peakVolume = currentVol;

      // Countdown / status display
      if (energy >= CONFIG.targetEnergy && !puzzleSolved) {
        // â•â•â• WIN! â•â•â•
        puzzleSolved = true;
        cancelAnimationFrame(animFrameId);
        countdownEl.textContent = 'ğŸ”¥ ××œ×! ğŸ”¥';
        countdownEl.classList.add('active');
        setTimeout(showSuccess, 600);
      } else if (currentVol >= CONFIG.minVolToCount) {
        countdownEl.classList.add('active');
        const remaining = CONFIG.targetEnergy - energy;
        countdownEl.textContent = `${Math.round(progress)}% â€” ×¢×•×“ ${Math.round(remaining)}!`;
      } else if (energy > 0) {
        countdownEl.classList.remove('active');
        countdownEl.textContent = energy > 50 ? 'ğŸ“¢ ×¦×¢×§×•! ×”××“ ×××ª×™×Ÿ!' : `${Math.round(progress)}% â€” ×§×“×™××”!`;
      } else {
        countdownEl.classList.remove('active');
        countdownEl.textContent = '';
      }
    }

    function triggerShake() {
      clearTimeout(shakeTimeout);
      document.body.classList.remove('shaking');
      // Force reflow
      void document.body.offsetWidth;
      document.body.classList.add('shaking');
      shakeTimeout = setTimeout(() => document.body.classList.remove('shaking'), 200);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Phase 3: Success
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function showSuccess() {
      // Stop mic
      if (micStream) micStream.getTracks().forEach(t => t.stop());
      if (audioCtx) audioCtx.close();
      redFlash.style.background = 'rgba(255,0,0,0)';
      document.body.classList.remove('shaking');
      dbMeterEl.style.display = 'none';

      document.getElementById('phase-puzzle').classList.add('hidden');
      document.getElementById('phase-success').classList.remove('hidden');
      document.getElementById('clue-display').textContent = CONFIG.clueText;
      spawnConfetti();
    }

    function spawnConfetti() {
      const colors = ['#ffd700', '#ff3366', '#33ccff', '#33ff66', '#ff8800', '#cc33ff'];
      for (let i = 0; i < 80; i++) {
        setTimeout(() => {
          const c = document.createElement('div');
          c.className = 'confetti';
          c.style.cssText = `left:${Math.random()*100}%;background:${colors[Math.floor(Math.random()*colors.length)]};width:${6+Math.random()*10}px;height:${6+Math.random()*10}px;border-radius:${Math.random()>0.5?'50%':'2px'};--fall-dur:${2+Math.random()*3}s;--rot:${Math.random()*720}deg;--drift:${-60+Math.random()*120}px;`;
          document.body.appendChild(c);
          setTimeout(() => c.remove(), 6000);
        }, i * 40);
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Reset
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function resetStation() {
      // Stop audio
      if (animFrameId) cancelAnimationFrame(animFrameId);
      if (micStream) micStream.getTracks().forEach(t => t.stop());
      if (audioCtx) { audioCtx.close(); audioCtx = null; }
      micStream = null; analyser = null;

      // Reset state
      colorDetected = false; matchCount = 0;
      puzzleActive = false; puzzleSolved = false;
      accumulatedEnergy = 0; peakVolume = 0; smoothedVolume = 0;
      dbMeterEl.style.display = 'none';

      // Reset UI
      redFlash.style.background = 'rgba(255,0,0,0)';
      document.body.classList.remove('shaking');
      meterFill.style.height = '0%';
      volumePercEl.textContent = '0%';
      countdownEl.textContent = '';
      countdownEl.classList.remove('active');
      hamanText.style.fontSize = '';
      micStatusEl.textContent = 'ğŸ¤ ×××–×™×Ÿ...';
      micStatusEl.classList.remove('active');

      document.getElementById('phase-success').classList.add('hidden');
      document.getElementById('phase-puzzle').classList.add('hidden');
      document.getElementById('phase-color').classList.remove('hidden');
      statusEl.textContent = 'ğŸ¨ ×¦×‘×¢×• ×“×£ ×œ×‘×Ÿ ×‘×¦×‘×¢ ×”× ×›×•×Ÿ ×•×”×¨×™××• ×œ××¦×œ××”';
      statusEl.style.color = 'rgba(255,255,255,0.7)';
      indicator.classList.remove('color-matched');
      indicator.style.background = '';
      startCamera();
    }
  </script>
</body>
</html>
